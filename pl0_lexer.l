/* $Id: pl0_lexer_definitions_top.l,v 1.2 2023/10/06 11:12:37 leavens Exp leavens $ */
/* Lexical Analyzer for PL/0 */

%option header-file = "pl0_lexer.h"
%option outfile = "pl0_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <limits.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"

 /* Tokens generated by Bison */
#include "pl0.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
char *filename;

/* Have any errors been noted? */
bool errors_noted;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);
// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.code = code;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void ident2ast(const char *name) {
    AST t;
    t.ident.file_loc = file_location_make(filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

static void number2ast(unsigned int val)
{
    AST t;
    t.number.file_loc = file_location_make(filename, yylineno);
    t.number.type_tag = number_ast;
    t.number.text = strdup(yytext);
    t.number.value = val;
    yylval = t;
}

%}

 /* you can add actual definitions below */
COMMENT               "#".*
ERROR                 .
IDENT                 [a-zA-Z_][_a-zA-Z0-9]*
NUMBER                [0-9]+
PLUS                  "+"  
MINUS                 "-"  
MULT                  "*"  
DIV                   "/"  
PERIOD                "."  
SEMICOLON             ";"  
EQUAL                 "="  
COMMA                 ","  
BECOMES               ":="  
CONST                 "const"  
PROCEDURE             "procedure"  
CALL                  "call"  
BEGIN                 "begin" 
END                   "end" 
IF                    "if"  
THEN                  "then"  
ELSE                  "else"  
WHILE                 "while"  
DO                    "do"  
READ                  "read"  
WRITE                 "write"  
SKIP                  "skip"  
ODD                   "odd"  
NOTEQUAL              "<>"  
LT                    "<"  
LEQ                   "<="  
GT                    ">"  
GEQ                   ">="  
LPAREN                "("  
RPAREN                ")"  
VAR                   "var"
WHITESPACE            [[:space:]\t\n]+

 /* the rules section starts after the %% below */
%%

 /* fill in the rules for your lexer here! */

 /* $Id: pl0_lexer_user_code.c,v 1.3 2023/10/06 11:12:37 leavens Exp leavens $ */
{COMMENT}    {/* Ignore one line comments*/}
{NUMBER}     {
                // Creates error message and gets current number length.
                char msg[1000];
                char intMaxStr[11];
                sprintf(intMaxStr, "%d", INT_MAX);
                sprintf(msg, "Number (%s) is too large!", yytext);
                int len = strlen(yytext);

                // Returns error if number has more than 10 digits.
                if (len > 10) {
                    yyerror(lexer_filename(), msg);  
                }

                // Checks if number is greater than INT_MAX and returns error if so.
                else if (len == 10) {
                    for (int i = 0; i < len; i++) {
                        if (yytext[i] > intMaxStr[i]) {
                            yyerror(lexer_filename(), msg);
                            break;
                        }
                        else if (yytext[i] < intMaxStr[i]) {
                            break;
                        }
                    } 
                }

                return numbersym;
             }
{WHITESPACE} {/* Ignore Whitespace*/ }
{PERIOD}     { tok2ast(periodsym); return periodsym; }
{MINUS}      { tok2ast(minussym); return minussym; }
{PLUS}       { tok2ast(plussym); return plussym; }
{MULT}       { tok2ast(multsym); return multsym; }
{DIV}        { tok2ast(divsym); return divsym; }
{PERIOD}     { tok2ast(periodsym); return periodsym; }
{SEMICOLON}  { tok2ast(semisym); return semisym; }
{EQUAL}      { tok2ast(eqsym); return eqsym; }
{COMMA}      { tok2ast(periodsym); return commasym; }
{BECOMES}    { tok2ast(becomessym); return becomessym; }
{VAR}        { tok2ast(varsym); return varsym; }
{CONST}      { tok2ast(constsym); return constsym;}
{PROCEDURE}  { tok2ast(proceduresym); return proceduresym; }
{IF}         { tok2ast(ifsym); return ifsym; }
{CALL}       { tok2ast(callsym); return callsym; }
{BEGIN}      { tok2ast(beginsym); return beginsym; }
{END}        { tok2ast(endsym); return endsym; }
{IF}         { tok2ast(ifsym); return ifsym; }
{THEN}       { tok2ast(thensym); return thensym; }
{ELSE}       { tok2ast(elsesym); return elsesym; }
{WHILE}      { tok2ast(whilesym); return whilesym; }
{DO}         { tok2ast(dosym); return dosym; }
{READ}       { tok2ast(readsym); return readsym; }
{WRITE}      { tok2ast(writesym); return writesym; }
{SKIP}       { tok2ast(skipsym); return skipsym; }
{ODD}        { tok2ast(oddsym); return oddsym; }
{NOTEQUAL}   { tok2ast(neqsym); return neqsym; }
{LT}         { tok2ast(ltsym); return ltsym; }
{LEQ}        { tok2ast(leqsym); return leqsym; }
{GT}         { tok2ast(gtsym); return gtsym; }
{GEQ}        { tok2ast(geqsym); return geqsym; }
{LPAREN}     { tok2ast(lparensym); return lparensym; }
{RPAREN}     { tok2ast(rparensym); return rparensym; }
{IDENT}      { tok2ast(identsym); return identsym; }
{ERROR}      {  // Returns error for undefined characters
                char* msg = malloc(1000 * sizeof(char));
                int ascii = yytext[0];
                sprintf(msg, "invalid character: '%s' ('\\%.3o')", yytext, ascii);
                yyerror(lexer_filename(), msg);
             }
%% 

/* This code goes in the user code section of the pl0_lexer`.l file,
   following the last %% above. */

// Requires: fname != NULL
// Requires: fname is the name of a readable file
// Initialize the lexer and start it reading
// from the given file name
void lexer_init(char *fname)
{
    errors_noted = false;
    yyin = fopen(fname, "r");
    if (yyin == NULL) {
	bail_with_error("Cannot open %s", fname);
    }
    filename = fname;
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
    if (yyin != NULL) {
	int rc = fclose(yyin);
	if (rc == EOF) {
	    bail_with_error("Cannot close %s!", filename);
	}
    }
    filename = NULL;
    return 1;  /* no more input */
}

// Return the name of the current input file
const char *lexer_filename() {
    return filename;
}

// Return the line number of the next token
unsigned int lexer_line() {
    return yylineno;
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg)
{
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s\n", filename, lexer_line(), msg);
    errors_noted = true;
}

// On standard output:
// Print a message about the file name of the lexer's input
// and then print a heading for the lexer's output.
void lexer_print_output_header()
{
    printf("Tokens from file %s\n", lexer_filename());
    printf("%-6s %-4s  %s\n", "Number", "Line", "Text");
}

// Print information about the token t to stdout
// followed by a newline
void lexer_print_token(enum yytokentype t, unsigned int tline,
		       const char *txt)
{
    printf("%-6d %-4d \"%s\"\n", t, tline, txt);
}


/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);
	if (t == YYEOF) {
	    break;
        }
        lexer_print_token(t, yylineno, yytext);
    } while (t != YYEOF);
}
